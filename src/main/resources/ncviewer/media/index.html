<!doctype html>
<html lang="en">

<head>
  <title>NC Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="UTF-8" />
  <style>
     html,
     body {
      background-color: #282a36;
      color: #f8f8f2;
      font-family: var(--idea-font-family, var(--vscode-font-family, 'JetBrains Mono', sans-serif));
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }

    main {
      height: 100%;
      width: 100%;
    }

    .viewer {
      width: 100%;
      height: 100%;
      background: #282a36;
      color: #f8f8f2;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
    }

    .viewer-info {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 8px 12px;
      background-color: rgba(40, 42, 54, 0.9);
      color: #f8f8f2;
      font-family: var(--idea-font-family, 'JetBrains Mono', monospace);
      font-size: 0.85rem;
      border: 1px solid #44475a;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    .viewer-info span {
      margin-bottom: 4px;
    }

    #viewerSlider {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 10px;
      background-color: #44475a;
      -webkit-appearance: none;
      appearance: none;
      border-radius: 5px;
      outline-color: var(--vscode-focusBorder);
      z-index: 1;
    }

    #viewerSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background-color: #bd93f9;
      border: 1px solid #f8f8f2;
      border-radius: 50%;
      cursor: pointer;
    }

    #viewerSlider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background-color: #bd93f9;
      border: 1px solid #f8f8f2;
      border-radius: 50%;
      cursor: pointer;
    }
  </style>
</head>

<body class="dark">

  <main>
    <div class="viewer" id="viewer">
      <div class="viewer-info" id="viewerInfo">
        <span>X: <span id="posX">0.000</span></span>
        <span>Y: <span id="posY">0.000</span></span>
        <span>Z: <span id="posZ">0.000</span></span>
      </div>
      <input type="range" id="viewerSlider" min="0" max="100" value="0" step="1" />
    </div>
  </main>

  <script src="./g_code_parser.js"></script>
  <script type="importmap">
      {
        "imports": {
          "three": "./libs/three.module.js",
          "three/addons/controls/OrbitControls.js": "./libs/addons/controls/OrbitControls.js",
          "three-viewport-gizmo": "./libs/three-viewport-gizmo.js"
        }
      }
    </script>

  <script type="module">
    import * as THREE from "three";
    import { ViewportGizmo } from "three-viewport-gizmo";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // VS Code API for receiving file data
    let ideaBridge = null;
    const bridgeLogQueue = [];

    const emitBridgeLog = (text) => {
      const message = `[bridge] ${text}`;
      console.debug(message);
      if (ideaBridge) {
        try {
          ideaBridge.postMessage({ type: "bridgeDebug", debugMessage: message });
        } catch (error) {
          console.error("Failed to post debug message", error);
        }
      } else {
        bridgeLogQueue.push(message);
      }
    };

    const flushBridgeLogQueue = () => {
      if (!ideaBridge) return;
      while (bridgeLogQueue.length) {
        const message = bridgeLogQueue.shift();
        try {
          ideaBridge.postMessage({ type: "bridgeDebug", debugMessage: message });
        } catch (error) {
          console.error("Failed to flush debug message", error);
          break;
        }
      }
    };

    const waitForIdeaBridge = (callback) => {
      if (
        window.ideaBridge &&
        typeof window.ideaBridge.postMessage === "function" &&
        typeof window.ideaBridge.addMessageListener === "function"
      ) {
        ideaBridge = window.ideaBridge;
        flushBridgeLogQueue();
        emitBridgeLog("ideaBridge connected");
        callback();
      } else {
        setTimeout(() => waitForIdeaBridge(callback), 50);
      }
    };

    const viewer = document.getElementById("viewer");
    const scene = new THREE.Scene();
    scene.up.set(0, 0, 1);
    const segmentsGroup = new THREE.Group();
    scene.add(segmentsGroup);

    const startPointGeometry = new THREE.SphereGeometry(1, 32, 32);
    const startPointMaterial = new THREE.MeshBasicMaterial({ color: 0x39ff14 });
    const startPointMesh = new THREE.Mesh(startPointGeometry, startPointMaterial);
    startPointMesh.visible = false;
    scene.add(startPointMesh);

    const endPointGeometry = new THREE.SphereGeometry(1, 32, 32);
    const endPointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const endPointMesh = new THREE.Mesh(endPointGeometry, endPointMaterial);
    endPointMesh.visible = false;
    scene.add(endPointMesh);

    const aspect = viewer.clientWidth / viewer.clientHeight;
    const f0 = 20000;
    const camera = new THREE.OrthographicCamera(
      (-f0 * aspect) / 2,
      (f0 * aspect) / 2,
      f0 / 2,
      -f0 / 2,
      0.1,
      2 * f0,
    );
    camera.up.set(0, 0, 1);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    viewer.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.mouseButtons = {
      LEFT: THREE.MOUSE.PAN,
      MIDDLE: THREE.MOUSE.ROTATE,
      RIGHT: null,
    };
    controls.screenSpacePanning = true;
    controls.zoomToCursor = true;

    const gizmo = new ViewportGizmo(camera, renderer, {
      placement: "bottom-right",
    });
    gizmo.attachControls(controls);

    let movements = [];
    let lineSegmentsMesh = null;
    let size = 0;

    const registerBridgeListeners = () => {
      ideaBridge.addMessageListener((eventData) => {
        let payload = eventData;
        if (typeof payload === "string") {
          try {
            payload = JSON.parse(payload);
          } catch (error) {
            console.error("Failed to parse incoming message", error, payload);
            emitBridgeLog("failed to parse incoming payload");
            return;
          }
        }

        if (!payload) {
          emitBridgeLog("incoming payload missing");
          return;
        }

        const { type, ncText, lineNumber, settings } = payload;
        emitBridgeLog(`incoming message type=${type}`);
        const excludeCodes = settings?.excludeCodes || [
          "G10",
          "G30",
          "G53",
          "G90",
        ];

        switch (type) {
          case "loadGCode":
            if (ncText !== undefined) {
              emitBridgeLog(`loadGCode received length=${ncText.length}`);
              processGCode(ncText, excludeCodes, true);
            }
            break;

          case "cursorPositionChanged":
            emitBridgeLog(`cursorPositionChanged ${lineNumber}`);
            highlightLineInViewer(lineNumber);
            break;

          case "contentChanged":
            if (ncText !== undefined) {
              emitBridgeLog(`contentChanged length=${ncText.length}`);
              processGCode(ncText, excludeCodes, false);
            }
            break;
        }
      });
    };
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isMouseDown = false;
    let mouseDownPosition = { x: 0, y: 0 };

    renderer.domElement.addEventListener("mousedown", (event) => {
      isMouseDown = true;
      mouseDownPosition.x = event.clientX;
      mouseDownPosition.y = event.clientY;
    });

    renderer.domElement.addEventListener("mouseup", (event) => {
      if (!isMouseDown) return;
      isMouseDown = false;

      const dx = event.clientX - mouseDownPosition.x;
      const dy = event.clientY - mouseDownPosition.y;
      const distanceSquared = dx * dx + dy * dy;
      const clickThreshold = 5 * 5;

      if (distanceSquared <= clickThreshold) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.params.Line.threshold = size / 100 / camera.zoom;
        raycaster.setFromCamera(mouse, camera);

        if (lineSegmentsMesh) {
          const intersects = raycaster.intersectObject(
            lineSegmentsMesh,
            false,
          );

          if (intersects.length > 0) {
            const intersect = intersects[0];
            const faceIndex = intersect.index;
            const segmentIndex = Math.floor(faceIndex / 2);

            if (segmentIndex < movements.length - 1) {
              const movement = movements[segmentIndex + 1];
              const lineIdx = movement.lineNumber || 0;

              emitBridgeLog(`click highlight line=${lineIdx}`);
              if (ideaBridge) {
                ideaBridge.postMessage({
                  type: "highlightLine",
                  lineNumber: lineIdx,
                });
              }

              highlightLineSegmentsForLine(lineIdx);
              slider.value = segmentIndex;
            }
          } else {
            slider.value = 0;
            selectLineSegments(movements.length, movements.length);
          }
        }
      }
    });

    function highlightLineInViewer(lineNumber) {
      let startIdx = -1;
      let endIdx = -1;

      for (let i = 1; i < movements.length; i++) {
        if (movements[i].lineNumber === lineNumber) {
          const segmentIdx = i - 1;
          if (startIdx === -1) startIdx = segmentIdx;
          endIdx = segmentIdx;
        }
      }

      if (startIdx !== -1 && endIdx !== -1) {
        slider.value = endIdx;
        selectLineSegments(startIdx, endIdx);
      }
    }

    function highlightLineSegmentsForLine(lineNumber) {
      let startIdx = -1;
      let endIdx = -1;

      for (let i = 1; i < movements.length; i++) {
        if (movements[i].lineNumber === lineNumber) {
          const segmentIdx = i - 1;
          if (startIdx === -1) startIdx = segmentIdx;
          endIdx = segmentIdx;
        }
      }

      if (startIdx !== -1 && endIdx !== -1) {
        selectLineSegments(startIdx, endIdx);
      }
    }
    function processGCode(gcode, excludeCodes, isInitialLoad = true) {
      clearSceneLines();

      movements = parseGCode(gcode, undefined, excludeCodes);
      console.log("Parsed movements:", movements);

      const positions = [];
      const colorsArray = [];

      const colorFeed = new THREE.Color(colors.feedColor);
      const colorRapid = new THREE.Color(colors.rapidColor);

      for (let i = 1; i < movements.length; i++) {
        const start = new THREE.Vector3(
          movements[i - 1].X,
          movements[i - 1].Y,
          movements[i - 1].Z,
        );
        const end = new THREE.Vector3(
          movements[i].X,
          movements[i].Y,
          movements[i].Z,
        );
        const isRapid = movements[i].command === "G0";
        const color = isRapid ? colorRapid : colorFeed;

        positions.push(start.x, start.y, start.z, end.x, end.y, end.z);
        colorsArray.push(
          color.r,
          color.g,
          color.b,
          color.r,
          color.g,
          color.b,
        );
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3),
      );
      geometry.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(colorsArray, 3),
      );

      const material = new THREE.LineBasicMaterial({ vertexColors: true });
      lineSegmentsMesh = new THREE.LineSegments(geometry, material);
      segmentsGroup.add(lineSegmentsMesh);

      slider.value = 0;
      slider.max = movements.length - 1;
      selectLineSegments(movements.length, movements.length);
      if (isInitialLoad) {
        resetCamera();
      }
    }

    function resetCamera() {
      let box = new THREE.Box3().setFromObject(segmentsGroup);

      if (box.isEmpty()) {
        box = new THREE.Box3(
          new THREE.Vector3(-1, -1, -1),
          new THREE.Vector3(1, 1, 1),
        );
      }

      size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());

      const f = size * 1.1;
      camera.left = (-f * aspect) / 2;
      camera.right = (f * aspect) / 2;
      camera.top = f / 2;
      camera.bottom = -f / 2;
      camera.zoom = 1;
      camera.updateProjectionMatrix();

      camera.position.set(
        center.x + size * 1.1,
        center.y + size * -1.1,
        size * 1.1,
      );
      camera.lookAt(center);

      controls.target.copy(center);
      controls.update();

      addAxisLines(box);
    }

    function clearSceneLines() {
      if (lineSegmentsMesh) {
        segmentsGroup.remove(lineSegmentsMesh);
        lineSegmentsMesh.geometry.dispose();
        lineSegmentsMesh.material.dispose();
        lineSegmentsMesh = null;
      }
      startPointMesh.visible = false;
      endPointMesh.visible = false;

      const axisLines = [];
      scene.traverse((child) => {
        if (child.userData.isAxisLine) {
          axisLines.push(child);
        }
      });

      axisLines.forEach((line) => scene.remove(line));
    }

    const slider = document.getElementById("viewerSlider");

    const registerSliderHandler = () => {
      slider.addEventListener("input", (event) => {
        const value = parseInt(event.target.value, 10);

        if (value >= 0 && value < movements.length - 1) {
          const startIdx = value;
          const endIdx = value;
          selectLineSegments(startIdx, endIdx);
          if (
            movements[value + 1] &&
            movements[value + 1].lineNumber !== undefined
          ) {
            const lineNumber = movements[value + 1].lineNumber;
            emitBridgeLog(`slider highlight line=${lineNumber}`);
            if (ideaBridge) {
              ideaBridge.postMessage({
                type: "highlightLine",
                lineNumber: lineNumber,
              });
            } else {
              emitBridgeLog("ideaBridge missing when sending highlightLine");
            }
          }
        }
      });
    };

    function addAxisLines(box) {
      const marginFactor = 0.2;
      const min = box.min;
      const max = box.max;

      const axes = [
        { dir: "x", color: 0xff3653, start: min.x, end: max.x },
        { dir: "y", color: 0x8adb00, start: min.y, end: max.y },
        { dir: "z", color: 0x2c8fff, start: min.z, end: max.z },
      ];

      axes.forEach(({ dir, color, start, end }) => {
        const length = end - start;
        const margin = length * marginFactor;

        let from = new THREE.Vector3();
        let to = new THREE.Vector3();

        if (dir === "x") {
          from.set(start - margin, 0, 0);
          to.set(end + margin, 0, 0);
        } else if (dir === "y") {
          from.set(0, start - margin, 0);
          to.set(0, end + margin, 0);
        } else if (dir === "z") {
          from.set(0, 0, start - margin);
          to.set(0, 0, end + margin);
        }

        const material = new THREE.LineBasicMaterial({
          color,
          depthTest: false,
          transparent: true,
          opacity: 0.8,
        });

        const geometry = new THREE.BufferGeometry().setFromPoints([from, to]);
        const line = new THREE.Line(geometry, material);
        line.userData.isAxisLine = true;

        scene.add(line);
      });
    }

    function selectLineSegments(startIdx, endIdx) {
      if (!lineSegmentsMesh) return;

      const colorAttr = lineSegmentsMesh.geometry.attributes.color;
      const color = new THREE.Color();

      for (let i = 0; i < movements.length - 1; i++) {
        const segmentIndex = i;
        const isSelected = segmentIndex >= startIdx && segmentIndex <= endIdx;
        const isAfter = segmentIndex > endIdx;

        const isRapid = movements[i + 1].command === "G0";
        let baseColor = isRapid ? colors.rapidColor : colors.feedColor;

        if (isSelected) {
          color.setHex(colors.selectedColor);
        } else {
          if (isAfter) {
            color.setHex(colors.afterSelColor);
          } else {
            color.setHex(baseColor);
          }
        }

        const vi = segmentIndex * 2;
        colorAttr.setXYZ(vi, color.r, color.g, color.b);
        colorAttr.setXYZ(vi + 1, color.r, color.g, color.b);
      }

      colorAttr.needsUpdate = true;

      if (startIdx < movements.length - 1) {
        const startPos = new THREE.Vector3(
          movements[startIdx].X,
          movements[startIdx].Y,
          movements[startIdx].Z,
        );
        const endPos = new THREE.Vector3(
          movements[endIdx + 1].X,
          movements[endIdx + 1].Y,
          movements[endIdx + 1].Z,
        );

        startPointMesh.position.copy(startPos);
        endPointMesh.position.copy(endPos);

        startPointMesh.visible = true;
        endPointMesh.visible = true;

        document.getElementById("posX").textContent =
          movements[endIdx + 1].X.toFixed(3);
        document.getElementById("posY").textContent =
          movements[endIdx + 1].Y.toFixed(3);
        document.getElementById("posZ").textContent =
          movements[endIdx + 1].Z.toFixed(3);
      } else {
        startPointMesh.visible = false;
        endPointMesh.visible = false;
        document.getElementById("posX").textContent = "0.000";
        document.getElementById("posY").textContent = "0.000";
        document.getElementById("posZ").textContent = "0.000";
      }
    }

    const DRACULA_COLORS = {
      feed: 0x50fa7b,
      rapid: 0xff5555,
      selected: 0xff79c6,
      afterSelected: 0x6272a4,
      background: 0x282a36,
    };

    let colors = {
      selectedColor: DRACULA_COLORS.selected,
      feedColor: DRACULA_COLORS.feed,
      rapidColor: DRACULA_COLORS.rapid,
      afterSelColor: DRACULA_COLORS.afterSelected,
    };

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      if (startPointMesh.visible) {
        const pointSize = (size / 200) / camera.zoom;
        startPointMesh.scale.set(pointSize, pointSize, pointSize);
        endPointMesh.scale.set(pointSize, pointSize, pointSize);
      }
      renderer.render(scene, camera);
      gizmo.render();
    }

    window.addEventListener("resize", function () {
      const viewerWidth = viewer.clientWidth;
      const viewerHeight = viewer.clientHeight;
      const newAspect = viewerWidth / viewerHeight;

      const viewSize = camera.top - camera.bottom;
      camera.left = (-viewSize * newAspect) / 2;
      camera.right = (viewSize * newAspect) / 2;
      camera.updateProjectionMatrix();

      renderer.setSize(viewerWidth, viewerHeight);
      gizmo.update();
    });

    function update3DViewColors() {
      colors.feedColor = DRACULA_COLORS.feed;
      colors.rapidColor = DRACULA_COLORS.rapid;
      colors.selectedColor = DRACULA_COLORS.selected;
      colors.afterSelColor = DRACULA_COLORS.afterSelected;

      startPointMaterial.color.setHex(colors.feedColor);
      endPointMaterial.color.setHex(colors.rapidColor);

      renderer.setClearColor(DRACULA_COLORS.background);

      // Redraw lines with new colors if they exist
      if (lineSegmentsMesh) {
        selectLineSegments(parseInt(slider.value, 10), parseInt(slider.value, 10));
      }

      // Redraw axis lines
      const axisLines = [];
      scene.traverse((child) => { if (child.userData.isAxisLine) axisLines.push(child); });
      axisLines.forEach((line) => scene.remove(line));
      let box = new THREE.Box3().setFromObject(segmentsGroup);
      if (box.isEmpty()) box = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));
      addAxisLines(box);
    }

    // Watch for theme changes
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          update3DViewColors();
          break;
        }
      }
    });
    observer.observe(document.body, { attributes: true });

    function initializeViewer() {
      emitBridgeLog("initializeViewer invoked");
      update3DViewColors();
      resetCamera();
      if (ideaBridge) {
        ideaBridge.postMessage({ type: "webviewReady" });
        emitBridgeLog("webviewReady posted");
      } else {
        emitBridgeLog("ideaBridge missing during initializeViewer");
      }
      animate();
    }

    const startOnceBridgeReady = () => {
      const start = () => {
        registerBridgeListeners();
        registerSliderHandler();
        initializeViewer();
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", start, { once: true });
      } else {
        start();
      }
    };

    waitForIdeaBridge(startOnceBridgeReady);

  </script>
</body>

</html>
